# Backend Infra

This document was generated by Gemini 2.5 Pro.

---
## **Overall Backend Architecture**

The platform is built using a **Microservices Architecture Pattern**. This design structures the application as a collection of small, independently deployable services that communicate through APIs. This pattern allows individual services to be developed, scaled, and deployed independently.

---

## Workspaces

This project uses Terraform workspaces to manage multiple environments. The available workspaces are `default` (for development) and `production`.

To switch between workspaces, use the following command:

```bash
terraform workspace select <workspace_name>
```

For example, to switch to the production workspace, run:

```bash
terraform workspace select production
```

### Backend

This project uses the S3 backend to store the Terraform state. Before you can use this project, you need to create the following resources:

*   An S3 bucket named `motion-terraform-state`
*   A DynamoDB table named `motion-terraform-locks` with a primary key named `LockID` of type `String`.

### Variables

Environment-specific variables are defined in `.tfvars` files. For example, the `production.tfvars` file contains the variables for the production environment.

To apply the Terraform configuration for a specific environment, use the `-var-file` flag. For example, to apply the production configuration, run:

```bash
terraform apply -var-file="production.tfvars"
```

## **Service Breakdown**

### **1. Mailing Service**

This microservice handles sending internal messages which also trigger external email notifications.

* **Technology**: Developed in **Go**.
* **Architecture**: Uses an **event-driven architecture** where services communicate asynchronously.
* **AWS Infrastructure**:
    * **Amazon SQS (Simple Queue Service)**: Acts as a message queue to decouple the application from the email delivery mechanism. When a user sends an email, a message event is published to the SQS queue.
    * **AWS Lambda**: A function continuously polls the SQS queue for new message events. When an event is detected, the Lambda function retrieves the message and prepares it for sending.
    * **Amazon SES (Simple Email Service)**: The Lambda function calls SES to handle the final delivery of the email, ensuring high reliability.
* **Design Pattern**:
    * **Clean Architecture**: This pattern is used to separate business logic from external dependencies and is structured in four layers:
        1.  **Domain Layer**: Contains core business logic and entities (e.g., Mail, User).
        2.  **Application Layer**: Encapsulates application-specific use cases, such as sending mail.
        3.  **Interface Layer**: Serves as the communication boundary, such as HTTP handlers for incoming requests.
        4.  **Infrastructure Layer**: Handles external dependencies like database access and interactions with SQS and SES.

### **2. User Registration & Authentication Service**

This service manages user account creation, login, and secure authentication.

* **Architecture**: Deployed as a microservice to be independent of other system functions.
* **Design Patterns**:
    * **Factory Pattern**: Used for creating different types of user accounts (e.g., standard user vs. administrator) while decoupling the creation logic.
    * **Singleton Pattern**: Ensures that services for managing tokens and validating sessions have only one instance, providing a global access point and maintaining a consistent state.
    * **Proxy Pattern**: Acts as an intermediary or "gatekeeper" to protect the core authorization systems. It intercepts requests to validate tokens and permissions before forwarding them to the actual service.
    * **Repository Pattern**: Abstracts the data layer, separating business logic from data storage and centralizing data access logic.
    * **Observer Pattern**: Notifies other parts of the system when a user's state changes, such as upon successful registration or login.

### **3. File Upload & Sharing Service**

This microservice enables users to upload, organize, and share files within their groups.

* **Architecture**: An independent microservice integrated with an external object storage system.
* **Infrastructure**:
    * **Object Storage (Amazon S3 or MinIO)**: Used to store the actual file content, which allows storage to scale independently of the main application.
    * **Relational Database (PostgreSQL)**: Stores file metadata, such as filename, uploader, timestamp, and permissions.
    * **API Gateway**: The frontend sends upload requests through an API Gateway.
* **Workflow**:
    * The service uses **pre-signed URLs** for direct S3 access.
    * When a user initiates an upload, the backend service validates permissions and generates a pre-signed URL, which is returned to the client.
    * The client then uploads the file directly to S3 using this URL, bypassing the backend to reduce server load.
* **Design Pattern**:
    * **Strategy Pattern**: Employed to handle storage, allowing the application to easily switch between different storage backends (e.g., Amazon S3, local storage) without altering the core upload logic.

### **4. Real-Time Group Messaging Service**

This service provides instant message exchange for users within group projects.

* **Technology**:
    * **Node.js with Socket.IO**: Facilitates real-time, bidirectional communication over WebSockets.
    * **Docker**: Used to containerize the service for deployment.
* **AWS Infrastructure**:
    * **Amazon DynamoDB**: A managed NoSQL database used for persistent message storage, partitioned by `project_id`.
    * **AWS ECS (Fargate)**: The containerized application is deployed