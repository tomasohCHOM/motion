// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspace_invites.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const acceptWorkspaceInvite = `-- name: AcceptWorkspaceInvite :one
UPDATE workspace_invites
SET
    status = 'accepted',
    invitee_id = $2
WHERE
    id = $1
    AND status = 'pending'
    AND expires_at > NOW()
RETURNING id, workspace_id, invited_by, invitee_id, invitee_email, access_type, status, created_at, expires_at
`

type AcceptWorkspaceInviteParams struct {
	ID        pgtype.UUID `json:"id"`
	InviteeID string      `json:"invitee_id"`
}

func (q *Queries) AcceptWorkspaceInvite(ctx context.Context, arg AcceptWorkspaceInviteParams) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, acceptWorkspaceInvite, arg.ID, arg.InviteeID)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InviteeID,
		&i.InviteeEmail,
		&i.AccessType,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createWorkspaceInvite = `-- name: CreateWorkspaceInvite :one
INSERT INTO workspace_invites (
    workspace_id,
    invited_by,
    invitee_id,
    invitee_email,
    access_type
) VALUES (
    $1,  -- workspace_id
    $2,  -- invited_by (user_id)
    $3,  -- invitee_id
    $4,  -- invitee_email
    COALESCE($5, 'member')  -- access_type
)
RETURNING id, workspace_id, invited_by, invitee_id, invitee_email, access_type, status, created_at, expires_at
`

type CreateWorkspaceInviteParams struct {
	WorkspaceID  pgtype.UUID `json:"workspace_id"`
	InvitedBy    string      `json:"invited_by"`
	InviteeID    string      `json:"invitee_id"`
	InviteeEmail string      `json:"invitee_email"`
	Column5      interface{} `json:"column_5"`
}

func (q *Queries) CreateWorkspaceInvite(ctx context.Context, arg CreateWorkspaceInviteParams) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, createWorkspaceInvite,
		arg.WorkspaceID,
		arg.InvitedBy,
		arg.InviteeID,
		arg.InviteeEmail,
		arg.Column5,
	)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InviteeID,
		&i.InviteeEmail,
		&i.AccessType,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const createWorkspaceInviteByIdentifier = `-- name: CreateWorkspaceInviteByIdentifier :one
INSERT INTO workspace_invites (
    workspace_id,
    invited_by,
    invitee_id,
    invitee_email,
    access_type
)
SELECT
    $1,          -- workspace_id
    $2,          -- invited_by
    u.id,        -- invitee_id from lookoup
    u.email,     -- invitee_email from lookup
    $3           -- access_type
FROM users u
WHERE u.email = $4 OR u.username = $4
RETURNING id, workspace_id, invited_by, invitee_id, invitee_email, access_type, status, created_at, expires_at
`

type CreateWorkspaceInviteByIdentifierParams struct {
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	InvitedBy   string      `json:"invited_by"`
	AccessType  pgtype.Text `json:"access_type"`
	Identifier  string      `json:"identifier"`
}

func (q *Queries) CreateWorkspaceInviteByIdentifier(ctx context.Context, arg CreateWorkspaceInviteByIdentifierParams) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, createWorkspaceInviteByIdentifier,
		arg.WorkspaceID,
		arg.InvitedBy,
		arg.AccessType,
		arg.Identifier,
	)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InviteeID,
		&i.InviteeEmail,
		&i.AccessType,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const deleteWorkspaceInvite = `-- name: DeleteWorkspaceInvite :exec
DELETE FROM workspace_invites
WHERE id = $1
`

func (q *Queries) DeleteWorkspaceInvite(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkspaceInvite, id)
	return err
}

const getInviteById = `-- name: GetInviteById :one
SELECT id, workspace_id, invited_by, invitee_id, invitee_email, access_type, status, created_at, expires_at FROM workspace_invites WHERE id = $1
`

func (q *Queries) GetInviteById(ctx context.Context, id pgtype.UUID) (WorkspaceInvite, error) {
	row := q.db.QueryRow(ctx, getInviteById, id)
	var i WorkspaceInvite
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.InvitedBy,
		&i.InviteeID,
		&i.InviteeEmail,
		&i.AccessType,
		&i.Status,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const listInvitesForUser = `-- name: ListInvitesForUser :many
SELECT
    wi.id,
    wi.workspace_id,
    w.name AS workspace_name,
    wi.invited_by,
    wi.invitee_id,
    wi.access_type,
    wi.status,
    wi.created_at,
    wi.expires_at
FROM workspace_invites wi
JOIN workspaces w ON wi.workspace_id = w.id
WHERE
    wi.invitee_id = $1
    AND wi.status = 'pending'
    AND wi.expires_at > NOW()
ORDER BY wi.created_at DESC
`

type ListInvitesForUserRow struct {
	ID            pgtype.UUID        `json:"id"`
	WorkspaceID   pgtype.UUID        `json:"workspace_id"`
	WorkspaceName string             `json:"workspace_name"`
	InvitedBy     string             `json:"invited_by"`
	InviteeID     string             `json:"invitee_id"`
	AccessType    pgtype.Text        `json:"access_type"`
	Status        pgtype.Text        `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	ExpiresAt     pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) ListInvitesForUser(ctx context.Context, inviteeID string) ([]ListInvitesForUserRow, error) {
	rows, err := q.db.Query(ctx, listInvitesForUser, inviteeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInvitesForUserRow
	for rows.Next() {
		var i ListInvitesForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.WorkspaceName,
			&i.InvitedBy,
			&i.InviteeID,
			&i.AccessType,
			&i.Status,
			&i.CreatedAt,
			&i.ExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
