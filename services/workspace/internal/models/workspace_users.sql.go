// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspace_users.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToWorkspace = `-- name: AddUserToWorkspace :exec
INSERT INTO workspace_users (user_id, workspace_id, access_type)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, workspace_id) DO UPDATE
    SET access_type = excluded.access_type
`

type AddUserToWorkspaceParams struct {
	UserID      string      `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	AccessType  pgtype.Text `json:"access_type"`
}

func (q *Queries) AddUserToWorkspace(ctx context.Context, arg AddUserToWorkspaceParams) error {
	_, err := q.db.Exec(ctx, addUserToWorkspace, arg.UserID, arg.WorkspaceID, arg.AccessType)
	return err
}

const getUserAccessType = `-- name: GetUserAccessType :one
SELECT access_type
FROM workspace_users
WHERE
    user_id = $1
    AND workspace_id = $2
`

type GetUserAccessTypeParams struct {
	UserID      string      `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

func (q *Queries) GetUserAccessType(ctx context.Context, arg GetUserAccessTypeParams) (pgtype.Text, error) {
	row := q.db.QueryRow(ctx, getUserAccessType, arg.UserID, arg.WorkspaceID)
	var access_type pgtype.Text
	err := row.Scan(&access_type)
	return access_type, err
}

const getUserWorkspaces = `-- name: GetUserWorkspaces :many
SELECT
    w.id,
    w.name,
    w.description,
    w.created_at,
    w.updated_at,
    COUNT(wu2.user_id) AS member_count
FROM workspaces AS w
INNER JOIN workspace_users AS wu ON w.id = wu.workspace_id
INNER JOIN workspace_users AS wu2 ON w.id = wu2.workspace_id
WHERE wu.user_id = $1
GROUP BY
    w.id,
    w.name,
    w.description,
    w.created_at,
    w.updated_at
ORDER BY w.created_at DESC
`

type GetUserWorkspacesRow struct {
	ID          pgtype.UUID      `json:"id"`
	Name        string           `json:"name"`
	Description pgtype.Text      `json:"description"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	MemberCount int64            `json:"member_count"`
}

func (q *Queries) GetUserWorkspaces(ctx context.Context, userID string) ([]GetUserWorkspacesRow, error) {
	rows, err := q.db.Query(ctx, getUserWorkspaces, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWorkspacesRow
	for rows.Next() {
		var i GetUserWorkspacesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.MemberCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkspaceUsers = `-- name: GetWorkspaceUsers :many
SELECT
    u.id,
    u.email,
    u.first_name,
    u.last_name,
    u.username,
    wu.access_type,
    wu.joined_at
FROM workspace_users AS wu
INNER JOIN users AS u ON wu.user_id = u.id
WHERE wu.workspace_id = $1
ORDER BY wu.joined_at ASC
`

type GetWorkspaceUsersRow struct {
	ID         string           `json:"id"`
	Email      string           `json:"email"`
	FirstName  string           `json:"first_name"`
	LastName   string           `json:"last_name"`
	Username   string           `json:"username"`
	AccessType pgtype.Text      `json:"access_type"`
	JoinedAt   pgtype.Timestamp `json:"joined_at"`
}

func (q *Queries) GetWorkspaceUsers(ctx context.Context, workspaceID pgtype.UUID) ([]GetWorkspaceUsersRow, error) {
	rows, err := q.db.Query(ctx, getWorkspaceUsers, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWorkspaceUsersRow
	for rows.Next() {
		var i GetWorkspaceUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.AccessType,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isWorkspaceUser = `-- name: IsWorkspaceUser :one
SELECT EXISTS(
    SELECT 1
    FROM workspace_users
    WHERE
        user_id = $1
        AND workspace_id = $2
)
`

type IsWorkspaceUserParams struct {
	UserID      string      `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

func (q *Queries) IsWorkspaceUser(ctx context.Context, arg IsWorkspaceUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, isWorkspaceUser, arg.UserID, arg.WorkspaceID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const removeUserFromWorkspace = `-- name: RemoveUserFromWorkspace :exec
DELETE FROM workspace_users
WHERE
    user_id = $1
    AND workspace_id = $2
`

type RemoveUserFromWorkspaceParams struct {
	UserID      string      `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
}

func (q *Queries) RemoveUserFromWorkspace(ctx context.Context, arg RemoveUserFromWorkspaceParams) error {
	_, err := q.db.Exec(ctx, removeUserFromWorkspace, arg.UserID, arg.WorkspaceID)
	return err
}

const updateUserAccessType = `-- name: UpdateUserAccessType :exec
UPDATE workspace_users
SET access_type = $3
WHERE
    user_id = $1
    AND workspace_id = $2
`

type UpdateUserAccessTypeParams struct {
	UserID      string      `json:"user_id"`
	WorkspaceID pgtype.UUID `json:"workspace_id"`
	AccessType  pgtype.Text `json:"access_type"`
}

func (q *Queries) UpdateUserAccessType(ctx context.Context, arg UpdateUserAccessTypeParams) error {
	_, err := q.db.Exec(ctx, updateUserAccessType, arg.UserID, arg.WorkspaceID, arg.AccessType)
	return err
}
